import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import datetime
import pandas as pd
from cleaning_operations import KCP_MAX
import helper_functions as hf
import helper_meta_data as hm
import helper_data as hd
import sys


# -----------------------------------------------------------------------------
# Declare important constants
# -----------------------------------------------------------------------------
ALLOWED_TAIL_DEVIATION = hm.ALLOWED_TAIL_DEVIATION
n_neighbours_list = hm.n_neighbours_list[:]
delta_x = hm.delta_x  # A Default value of 1.
x_limits = hm.x_limits[:]  # [0, 365]
pol_degree = hf.pol_degree
season_xticks = hd.season_xticks
datetime_stamp = hm.datetime_stamp[:]
mode = hm.mode  # The `default` at which we start out (which is "WMA").
# "WMA" stands for Weighted-Moving-Average; "Pol" is short for Polynomial-fit.
# -----------------------------------------------------------------------------


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Import all the necessary data
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Get the DataFrame containing all the cleaned (date, kcp) data samples.
cleaned_df = hd.cleaned_df.copy(deep=True)

# Get the list of all the probe-id names.
probe_ids = hm.probe_ids[:]

# Get the starting year:
starting_year = hm.starting_year
season_start_date = hm.season_start_date
season_end_date = hm.season_end_date

# Get the DataFrame storing the reference crop coefficients:
cco_df = hd.cco_df.copy(deep=True)
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# =============================================================================
# Remove old files generated by a previous execution of this script.
# =============================================================================
file_list = ["./data/prized_index.txt", "./data/prized_n_neighbours.txt",
             "./figures/first_smoothed_kcp_versus_days.png",
             "./figures/first_smoothed_kcp_versus_month.png",
             "./data/statistics_wma_trend_lines.txt",
             "./data/statistics_polynomial_fit.txt",
             "./data/mode.txt", "./data/first_smoothed_kcp_trend.xlsx",
             "./data/cleaned_and_sorted_kcp.xlsx"]
hf.safe_removal(file_list=file_list)
# =============================================================================


# =============================================================================
# Perform weighted-moving-average trends to the cleaned_df data.
# Make plots of `kcp versus Days into the Season` of the WMA trends.
# Here, the x-axis is simply an integer (Number of Days).
# The y-axis is (cleaned) kcp.
# =============================================================================
independent_var = cleaned_df["x_scatter"].values
dependent_var = cleaned_df["y_scatter"].values  # the crop coefficient, kcp.

saved_trend_lines = []  # this will store all the various trend lines.
r_squared_stats = []
num_bumps = []

tracker = 0
for n_neighbours in n_neighbours_list:
    try:
        x_smoothed, y_smoothed = hf.weighted_moving_average(x=independent_var,
                                                            y=dependent_var,
                                                            step_size=delta_x,
                                                            width=n_neighbours,
                                                            x_lims=x_limits,
                                                            append_=True)
        saved_trend_lines.append(zip(x_smoothed, y_smoothed))
        r_squared_stats.append(hf.get_r_squared(x_raw=independent_var,
                                                y_raw=dependent_var,
                                                x_fit=x_smoothed,
                                                y_fit=y_smoothed))
        num_bumps.append(hf.get_n_local_extrema(y_smoothed))
        tracker += 1
    except ZeroDivisionError:
        n_neighbours_list = n_neighbours_list[:tracker]  # truncate
        break  # exit the for-loop.  n_neighbours has become too small.
try:
    prized_index = hf.get_prized_index(num_bumps)
    trend_line = saved_trend_lines[prized_index]
    unpack = [list(t) for t in zip(*trend_line)]
    x_smoothed, y_smoothed = unpack[0], unpack[1]
    with open("./data/prized_index.txt", "w") as f:
        f.write("{:.0f}".format(prized_index))
    with open("./data/prized_n_neighbours.txt", "w") as f:
        f.write("{:.0f}".format(n_neighbours_list[prized_index]))
except hf.NoProperWMATrend as e:
    print(str(e))
    print("Cannot perform WMA.")
    print("Proceeding with Polynomial Fit.")
    r_squared_stats = list()
    mode = "Polynomial-fit"  # Switch over to the new mode.
    x_smoothed, y_smoothed = hf.get_final_polynomial_fit(x_raw=independent_var,
                                                         y_raw=dependent_var,
                                                         step_size=delta_x,
                                                         degree=hf.pol_degree,
                                                         x_lims=x_limits)
    r_squared_stats.append(hf.get_r_squared(x_raw=independent_var,
                                            y_raw=dependent_var,
                                            x_fit=x_smoothed,
                                            y_fit=y_smoothed))

# We need to safe-check the reasonableness of the smoothed trendline.
# In particular, check if the tail standards are met with the `hf.check_tails`
# function.
if mode == "WMA":
    print("We are still in \"WMA\" mode.\n")
    tail_status = hf.check_tails(y_trendline=y_smoothed,
                                 leading_ref=cco_df["cco"].values[0],
                                 trailing_ref=cco_df["cco"].values[-1],
                                 allowed_dev=ALLOWED_TAIL_DEVIATION,
                                 suppress_check=False)
    # I.e., if `tail_status` is True:
    if tail_status:
        pass
    # I.e., `tail_status` is False, and we need to proceed with Polynomial-fit.
    else:
        print("Tail standards are not met in WMA mode.\n"
              "Proceeding with Polynomial-fit.\n")
        mode = "Polynomial-fit"
        print("We have switched over to \"Polynomial-fit\" mode.\n")
        x_smoothed, y_smoothed = \
            hf.get_final_polynomial_fit(x_raw=independent_var,
                                        y_raw=dependent_var,
                                        step_size=delta_x,
                                        degree=hf.pol_degree,
                                        x_lims=x_limits)
        r_squared_pol = hf.get_r_squared(x_raw=independent_var,
                                         y_raw=dependent_var,
                                         x_fit=x_smoothed, y_fit=y_smoothed)
        print("r_squared_pol = {:.4f}.".format(r_squared_pol))
        r_squared_stats = list()
        r_squared_stats.append(hf.get_r_squared(x_raw=independent_var,
                                                y_raw=dependent_var,
                                                x_fit=x_smoothed,
                                                y_fit=y_smoothed))
if mode == "Polynomial-fit":
    print("It appears we have resorted to \"Polynomial-fit\" mode.\n"
          "Proceeding to check if tail standards are met.\n")
    tail_status = hf.check_tails(y_trendline=y_smoothed,
                                 leading_ref=cco_df["cco"].values[0],
                                 trailing_ref=cco_df["cco"].values[-1],
                                 allowed_dev=ALLOWED_TAIL_DEVIATION,
                                 suppress_check=False)
    # I.e., if `tail_status` is True:
    if tail_status:
        print("The tail-standards are met while in \"Polynomial-fit\" mode.\n")
        pass
    else:
        print("Tail standards are not met while in \"Polynomial-fit\" mode.\n"
              "A smoothed trendline cannot be generated for this data set.\n"
              "Try adding more probes to the probe-set.\n"
              "Additional data points at the tailpoints would be a bonus.\n")
        sys.exit("Tail standards are not met.  Cannot generate a smoothed "
                 "trendline for this data set.")

# Save the scatter plot and trend line to
# "./figures/first_smoothed_kcp_versus_days.png".
_, ax = plt.subplots(figsize=(10, 5))
ax.set_xlabel("Season Day")
ax.set_ylabel("$k_{cp}$")
ax.set_title("Smoothed $k_{cp}$ versus Season Day")
ax.grid(True)
ax.set_xlim(left=x_limits[0], right=x_limits[1])
ax.set_ylim(bottom=0.0, top=KCP_MAX)
major_xticks = np.arange(start=x_limits[0], stop=x_limits[1], step=30)
ax.set_xticks(major_xticks)
ax.plot(x_smoothed, y_smoothed, alpha=0.70, label=mode)
ax.scatter(independent_var, dependent_var, c="magenta", marker=".",
           edgecolors="black", alpha=0.5, label="Cleaned Probe Data")
ax.scatter(cco_df["season_day"].values, cco_df["cco"].values, c="yellow",
           marker=".", alpha=0.5, label="Reference $k_{cp}$")
ax.legend()
plt.tight_layout()
plt.savefig("./figures/first_smoothed_kcp_versus_days.png")
plt.close()
# =============================================================================


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Create another plot where the x-axis is of type datetime.
# In this new plot we have `kcp versus Month of the Season`.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
while len(y_smoothed) > len(datetime_stamp):
    print("Performing a .pop() on y_smoothed and x_smoothed.")
    y_smoothed.pop()
    x_smoothed.pop()

assert len(y_smoothed) == len(datetime_stamp), "Iterables are NOT of the " \
                                               "same length."
assert len(x_smoothed) == len(datetime_stamp), "Iterables are NOT of the " \
                                               "same length."

# `datetime_clouded` is a list of datetime objects that will serve as the x-
# axis when making the scatter plot.
datetime_clouded = []
for i in independent_var:
    days = float(i)
    datetime_clouded.append(season_start_date +
                            datetime.timedelta(days=days))

# The figure is saved at "./figures/first_smoothed_kcp_versus_month.png".
fig, ax = plt.subplots(figsize=(10, 5))
ax.set_xticks(season_xticks)
ax.set_xlabel("Date (Month of the Season)")
ax.set_ylabel("$k_{cp}$")
ax.set_title("Smoothed $k_{cp}$ versus Month of the Season")
ax.grid(True)
ax.set_xlim(left=season_start_date, right=season_end_date)
ax.xaxis.set_major_formatter(mdates.DateFormatter('%b/%d'))  # Month/01
ax.set_ylim(bottom=0.0, top=KCP_MAX)
ax.plot(datetime_stamp, y_smoothed, alpha=0.70, label=mode)
ax.scatter(datetime_clouded, dependent_var, c="magenta", marker=".",
           edgecolors="black", alpha=0.5, label="Cleaned Probe Data")
ax.scatter(cco_df.index, cco_df["cco"].values, c="yellow", marker=".",
           alpha=0.3, label="Reference $k_{cp}$, \"cco\"")
ax.legend()
fig.autofmt_xdate()  # rotate and align the tick labels so they look better
plt.tight_layout()
plt.savefig("./figures/first_smoothed_kcp_versus_month.png")
plt.close()
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# -----------------------------------------------------------------------------
# Write the r-squared statistics to file
# If mode == "WMA", then each line corresponds to the n_neighbours and
# r_squared.
# Else, if mode == "Polynomial-fit", then a single line will contain the
# highest order of the polynomial, and the r_squared of that polynomial.
# -----------------------------------------------------------------------------
if mode == "WMA":
    with open("./data/statistics_wma_trend_lines.txt", "w") as f:
        f.write("n_neighbours | r_squared_statistic\n")
        for i, nn in enumerate(n_neighbours_list):
            f.write("{:.0f} | {:.7f}\n".format(nn, r_squared_stats[i]))
else:
    with open("./data/statistics_polynomial_fit.txt", "w") as f:
        f.write("highest_order | r_squared_statistic\n")
        f.write("{:.0f} | {:.7f}\n".format(pol_degree, r_squared_stats[0]))
# -----------------------------------------------------------------------------


# =============================================================================
# Save the final `mode`.
# Save the data related to the best-fitting trend line.
# Save the chronological data of the cleaned kcp data.
# =============================================================================
# Save the final `mode` to "./data/mode.txt".
with open("./data/mode.txt", "w") as f:
    f.write(mode)

# Save the data related to the first best-fitting trend line to
# "./data/first_smoothed_kcp_trend_vs_datetime.xlsx".
df = pd.DataFrame(data={"x_smoothed": x_smoothed,
                        "y_smoothed": y_smoothed},
                  index=datetime_stamp, columns=["x_smoothed",
                                                 "y_smoothed"],
                  copy=True)
df.to_excel("./data/first_smoothed_kcp_trend.xlsx",
            float_format="%.7f", columns=["x_smoothed", "y_smoothed"],
            header=True, index=True, index_label="datetime_stamp")

# Save the (sorted) data of the cleaned kcp data to an Excel file stored at
# "./data/cleaned_and_sorted_kcp.xlsx".
cleaned_df.to_excel("data/cleaned_and_sorted_kcp.xlsx", header=True,
                    index=True, index_label="datetime_stamp",
                    columns=["x_scatter", "y_scatter"], float_format="%.7f")
# =============================================================================
